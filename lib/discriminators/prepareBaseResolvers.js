"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.prepareBaseResolvers = prepareBaseResolvers;

var _graphqlCompose = require("graphql-compose");

var _resolvers = require("../resolvers");

var _DiscriminatorTypeComposer = require("./DiscriminatorTypeComposer");

const GraphQLList = _graphqlCompose.graphql.GraphQLList,
      GraphQLNonNull = _graphqlCompose.graphql.GraphQLNonNull; // change type on DKey generated by composeWithMongoose
// set it to created enum TypeComposer for DKey DKeyETC
// only sets on filter and record typeComposers, since they contain our DKey

function setDKeyEnumOnITCArgs(resolver, baseTC) {
  // setDKeyEnum for filter types, and on record types
  if (resolver) {
    const argNames = resolver.getArgNames();
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = argNames[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        const argName = _step.value;

        if (argName === 'filter' || argName === 'record' || argName === 'records') {
          const filterArgTC = resolver.getArgTC(argName);

          if (filterArgTC) {
            filterArgTC.extendField(baseTC.getDKey(), {
              type: baseTC.getDKeyETC()
            });
          }
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  }
} // recomposing sets up the DInterface as the return types for
// Also sets up DKey enum as type for DKey field on composers with filter and/or record args
// composeWithMongoose composers


function prepareBaseResolvers(baseTC) {
  for (const resolverName in _resolvers.EMCResolvers) {
    if (_resolvers.EMCResolvers.hasOwnProperty(resolverName) && baseTC.hasResolver(resolverName)) {
      const resolver = baseTC.getResolver(resolverName);

      switch (resolverName) {
        case _resolvers.EMCResolvers.findMany:
        case _resolvers.EMCResolvers.findByIds:
          resolver.setType(new GraphQLList(baseTC.getDInterface().getType()));
          break;

        case _resolvers.EMCResolvers.findById:
        case _resolvers.EMCResolvers.findOne:
          resolver.setType(baseTC.getDInterface());
          break;

        case _resolvers.EMCResolvers.createOne:
        case _resolvers.EMCResolvers.updateOne:
        case _resolvers.EMCResolvers.updateById:
        case _resolvers.EMCResolvers.removeOne:
        case _resolvers.EMCResolvers.removeById:
          resolver.getTypeComposer().extendField('record', {
            type: baseTC.getDInterface()
          });
          break;

        case _resolvers.EMCResolvers.createMany:
          resolver.getTypeComposer().extendField('records', {
            type: new GraphQLNonNull(GraphQLList(baseTC.getDInterface().getType()))
          });
          break;

        case _resolvers.EMCResolvers.pagination:
          resolver.getTypeComposer().extendField('items', {
            type: new GraphQLList(baseTC.getDInterface().getType())
          });
          break;

        case _resolvers.EMCResolvers.connection:
          const edgesTC = resolver // eslint-disable-line no-case-declarations
          .getTypeComposer().getFieldTC('edges').clone(`${baseTC.getTypeName()}Edge`);
          edgesTC.extendField('node', {
            type: new GraphQLNonNull(baseTC.getDInterface().getType())
          });
          resolver.getTypeComposer().setField('edges', new GraphQLNonNull(new GraphQLList(new GraphQLNonNull(edgesTC.getType()))));
          break;

        default:
      }

      setDKeyEnumOnITCArgs(resolver, baseTC); // set DKey as required field to create from base
      // must be done after setting DKeyEnum

      if (resolverName === _resolvers.EMCResolvers.createOne || resolverName === _resolvers.EMCResolvers.createMany) {
        const fieldName = resolverName === _resolvers.EMCResolvers.createMany ? 'records' : 'record';
        resolver.getArgTC(fieldName).extendField(baseTC.getDKey(), {
          type: baseTC.getDKeyETC().getTypeNonNull()
        });
      }
    }
  }
}